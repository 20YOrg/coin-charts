<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coin Charts</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #chart-container { width: 100%; height: 100vh; position: relative; }
        canvas { width: 100%; height: 100%; }
        #controls { position: absolute; top: 10px; right: 60px; z-index: 10; }
        select { padding: 5px; font-size: 14px; }
    </style>
</head>
<body>
    <div id="chart-container">
        <canvas id="chart"></canvas>
        <div id="controls">
            <label for="scale-select">Price Scale: </label>
            <select id="scale-select">
                <option value="linear">Linear</option>
                <option value="logarithmic">Logarithmic</option>
            </select>
        </div>
    </div>
    <script>
        class Chart {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.data = options.data || [];
                this.options = {
                    candleWidth: options.candleWidth || 10,
                    upColor: options.upColor || '#00ff00',
                    downColor: options.downColor || '#ff0000',
                    background: options.background || '#ffffff',
                    axisColor: options.axisColor || '#000000',
                    scaleType: options.scaleType || 'linear',
                };
                this.view = {
                    offsetX: 0,
                    scaleX: 1,
                    scaleY: 1,
                    minPrice: 0,
                    maxPrice: 100,
                    minLogPrice: 0,
                    maxLogPrice: 0,
                };
                this.isDragging = false;
                this.lastMouseX = 0;

                this.resize();
                this.initEvents();
                this.render();
            }

            resize() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.canvas.offsetWidth * dpr;
                this.canvas.height = this.canvas.offsetHeight * dpr;
                this.ctx.scale(dpr, dpr);
                this.render();
            }

            initEvents() {
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const width = this.canvas.offsetWidth;
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;

                    if (mouseX > width - 50) {
                        // Price axis zoom (y-axis)
                        if (this.options.scaleType === 'logarithmic') {
                            const logRange = this.view.maxLogPrice - this.view.minLogPrice;
                            const newLogRange = logRange / zoomFactor;
                            const logMid = (this.view.maxLogPrice + this.view.minLogPrice) / 2;
                            this.view.minLogPrice = logMid - newLogRange / 2;
                            this.view.maxLogPrice = logMid + newLogRange / 2;
                            this.view.minPrice = Math.pow(10, this.view.minLogPrice);
                            this.view.maxPrice = Math.pow(10, this.view.maxLogPrice);
                        } else {
                            const priceRange = this.view.maxPrice - this.view.minPrice;
                            const newPriceRange = priceRange / zoomFactor;
                            const priceMid = (this.view.maxPrice + this.view.minPrice) / 2;
                            this.view.minPrice = Math.max(priceMid - newPriceRange / 2, 0.01);
                            this.view.maxPrice = priceMid + newPriceRange / 2;
                            this.view.minLogPrice = Math.log10(this.view.minPrice);
                            this.view.maxLogPrice = Math.log10(this.view.maxPrice);
                        }
                    } else {
                        // Time axis zoom (x-axis)
                        this.view.scaleX *= zoomFactor;
                    }

                    this.render();
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDragging = true;
                    this.lastMouseX = e.clientX;
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDragging) {
                        const dx = e.clientX - this.lastMouseX;
                        this.view.offsetX += dx / this.view.scaleX;
                        this.lastMouseX = e.clientX;
                        this.render();
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    this.isDragging = false;
                });

                const scaleSelect = document.getElementById('scale-select');
                scaleSelect.addEventListener('change', (e) => {
                    this.options.scaleType = e.target.value;
                    this.render();
                });

                window.addEventListener('resize', () => this.resize());
            }

            calculatePriceRange() {
                if (!this.data.length) return;
                const prices = this.data.flatMap(d => [d.high, d.low]);
                const dataMinPrice = Math.min(...prices);
                const dataMaxPrice = Math.max(...prices);
                const padding = (dataMaxPrice - dataMinPrice) * 0.1;
                if (this.view.minPrice === 0 && this.view.maxPrice === 100) {
                    this.view.minPrice = Math.max(dataMinPrice - padding, 0.01);
                    this.view.maxPrice = dataMaxPrice + padding;
                    this.view.minLogPrice = Math.log10(this.view.minPrice);
                    this.view.maxLogPrice = Math.log10(this.view.maxPrice);
                }
            }

            priceToY(price, height) {
                if (this.options.scaleType === 'logarithmic') {
                    const logPrice = Math.log10(Math.max(price, 0.01));
                    const logRange = this.view.maxLogPrice - this.view.minLogPrice;
                    return height - ((logPrice - this.view.minLogPrice) / logRange) * height;
                } else {
                    const priceRange = this.view.maxPrice - this.view.minPrice;
                    return height - ((price - this.view.minPrice) / priceRange) * height;
                }
            }

            yToPrice(y, height) {
                if (this.options.scaleType === 'logarithmic') {
                    const logRange = this.view.maxLogPrice - this.view.minLogPrice;
                    const logPrice = this.view.minLogPrice + (1 - y / height) * logRange;
                    return Math.pow(10, logPrice);
                } else {
                    const priceRange = this.view.maxPrice - this.view.minPrice;
                    return this.view.minPrice + (1 - y / height) * priceRange;
                }
            }

            formatDate(dateStr) {
                const date = new Date(dateStr);
                return date.toISOString().split('T')[0];
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = this.options.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.data.length) return;

                this.calculatePriceRange();
                const width = this.canvas.offsetWidth;
                const height = this.canvas.offsetHeight;
                const axisMargin = 30;
                const chartHeight = height - axisMargin;
                const candleWidth = this.options.candleWidth * this.view.scaleX;
                const spacing = candleWidth / 4;

                this.data.forEach((candle, i) => {
                    const x = (i * (candleWidth + spacing) + this.view.offsetX) * this.view.scaleX;
                    if (x < -candleWidth || x > width) return;

                    const isUp = candle.close >= candle.open;
                    this.ctx.fillStyle = isUp ? this.options.upColor : this.options.downColor;

                    const highY = this.priceToY(candle.high, chartHeight);
                    const lowY = this.priceToY(candle.low, chartHeight);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + candleWidth / 2, highY);
                    this.ctx.lineTo(x + candleWidth / 2, lowY);
                    this.ctx.strokeStyle = this.ctx.fillStyle;
                    this.ctx.stroke();

                    const openY = this.priceToY(candle.open, chartHeight);
                    const closeY = this.priceToY(candle.close, chartHeight);
                    const bodyHeight = Math.abs(openY - closeY);
                    const bodyY = Math.min(openY, closeY);
                    this.ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
                });

                this.ctx.strokeStyle = this.options.axisColor;
                this.ctx.beginPath();
                this.ctx.moveTo(width - 50, 0);
                this.ctx.lineTo(width - 50, chartHeight);
                this.ctx.stroke();

                this.ctx.fillStyle = this.options.axisColor;
                this.ctx.font = '12px Arial';
                const priceSteps = 5;
                for (let i = 0; i <= priceSteps; i++) {
                    const y = (chartHeight * i) / priceSteps;
                    const price = this.yToPrice(y, chartHeight);
                    this.ctx.fillText(price.toFixed(2), width - 45, chartHeight - y);
                }

                this.ctx.beginPath();
                this.ctx.moveTo(0, chartHeight);
                this.ctx.lineTo(width - 50, chartHeight);
                this.ctx.stroke();

                const labelInterval = Math.max(1, Math.floor(100 / (candleWidth + spacing)));
                this.data.forEach((candle, i) => {
                    if (i % labelInterval === 0) {
                        const x = (i * (candleWidth + spacing) + this.view.offsetX) * this.view.scaleX;
                        if (x >= 0 && x <= width - 50) {
                            this.ctx.fillText(this.formatDate(candle.time), x, chartHeight + 20);
                        }
                    }
                });
            }

            setData(data) {
                this.data = data;
                this.render();
            }
        }

        const sampleData = [
            { time: '2025-05-01', open: 100, high: 110, low: 95, close: 105 },
            { time: '2025-05-02', open: 105, high: 115, low: 100, close: 112 },
            { time: '2025-05-03', open: 112, high: 120, low: 108, close: 110 },
            { time: '2025-05-04', open: 110, high: 115, low: 105, close: 108 },
            { time: '2025-05-05', open: 108, high: 112, low: 102, close: 111 },
            { time: '2025-05-06', open: 111, high: 118, low: 109, close: 115 },
            { time: '2025-05-07', open: 115, high: 122, low: 113, close: 120 },
            { time: '2025-05-08', open: 120, high: 125, low: 118, close: 123 },
            { time: '2025-05-09', open: 123, high: 130, low: 121, close: 128 },
            { time: '2025-05-10', open: 128, high: 135, low: 125, close: 130 },
        ];

        const canvas = document.getElementById('chart');
        const chart = new Chart(canvas, {
            data: sampleData,
            candleWidth: 10,
            upColor: '#00ff00',
            downColor: '#ff0000',
            background: '#f0f0f0',
            axisColor: '#333333',
            scaleType: 'linear',
        });
    </script>
</body>
</html>
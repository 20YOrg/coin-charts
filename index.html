<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coin Charts</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }

        #chart-container {
            width: 100%;
            height: 100vh;
            position: relative;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            top: 10px;
            right: 60px;
            z-index: 10;
        }

        select {
            padding: 5px;
            font-size: 14px;
        }

        #tool-menu {
            position: absolute;
            left: 10px;
            top: 10px;
            width: 40px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px 0;
        }

        #tool-menu button {
            width: 30px;
            height: 30px;
            margin: 5px 0;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #333;
            transition: background-color 0.2s;
        }

        #tool-menu button:hover {
            background-color: #e0e0e0;
            border-radius: 4px;
        }

        #tool-menu button.active {
            background-color: #d0d0d0;
        }
    </style>
</head>

<body>
    <div id="chart-container">
        <canvas id="chart"></canvas>
        <div id="controls">
            <label for="scale-select">Price Scale: </label>
            <select id="scale-select">
                <option value="linear">Linear</option>
                <option value="logarithmic">Logarithmic</option>
            </select>
        </div>
        <div id="tool-menu">
            <button id="tool-crosshair" title="Toggle Crosshair">âœ›</button>
            <button id="tool-ma" title="Toggle Moving Average">ðŸ“ˆ</button>
            <button id="tool-reset" title="Reset View">â†»</button>
        </div>
    </div>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
            return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
            if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
                try {
                    var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                    var firstSheetName = workbook.SheetNames[0];
                    var worksheet = workbook.Sheets[firstSheetName];
                    var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                    var filteredData = jsonData.filter(row => row.some(filledCell));
                    var headerRowIndex = filteredData.findIndex((row, index) =>
                        row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                    );
                    if (headerRowIndex === -1 || headerRowIndex > 25) {
                        headerRowIndex = 0;
                    }
                    var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
                    csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                    return csv;
                } catch (e) {
                    console.error(e);
                    return "";
                }
            }
            return gk_fileData[filename] || "";
        }
    </script>
    <script>
        /**
         * Manages chart data and loading
         */
        class DataManager {
            constructor(chart) {
                this.chart = chart;
                this.data = [];
            }

            setData(data) {
                this.data = data.filter(d => {
                    const date = new Date(d.time);
                    return d.time && !isNaN(date.getTime()) && !isNaN(d.open) && !isNaN(d.high) && !isNaN(d.low) && !isNaN(d.close);
                });
                this.chart.render();
            }

            async loadDataFromCSV(url) {
                try {
                    const response = await fetch(url);
                    const csvText = await response.text();
                    const rows = csvText.split('\n').map(row => row.split(','));
                    const headers = rows[0];
                    const data = rows.slice(1).map(row => ({
                        time: row[0],
                        open: parseFloat(row[1]),
                        high: parseFloat(row[2]),
                        low: parseFloat(row[3]),
                        close: parseFloat(row[4]),
                    })).filter(row => row.time && !isNaN(row.close));
                    this.setData(data);
                } catch (e) {
                    console.error('Failed to load CSV:', e);
                }
            }
        }

        /**
         * Candlestick chart class
         */
        class Chart {
            constructor(canvas, options = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.dataManager = new DataManager(this);
                this.options = {
                    candleWidth: options.candleWidth || 10,
                    upColor: options.upColor || '#F08852',
                    downColor: options.downColor || '#6D96E7',
                    background: options.background || '#FFFFFF',
                    axisColor: options.axisColor || '#000000',
                    scaleType: options.scaleType || 'linear',
                    gridColor: options.gridColor || '#F3F3F3',
                };
                this.view = {
                    offsetX: 0,
                    scaleX: 1,
                    scaleY: 1,
                    minPrice: 0,
                    maxPrice: 100,
                    minLogPrice: 0,
                    maxLogPrice: 0,
                };
                this.isDragging = false;
                this.lastMouseX = 0;
                this.crosshair = null;
                this.showCrosshair = true;
                this.showMovingAverage = true;
                this.minScaleX = 0.5; // Min zoom (candles ~5px)
                this.maxScaleX = 5;   // Max zoom (candles ~50px)

                this.resize();
                this.initEvents();
                this.dataManager.setData(options.data || []);
                this.render();
            }

            resize() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.canvas.offsetWidth * dpr;
                this.canvas.height = this.canvas.offsetHeight * dpr;
                this.ctx.scale(dpr, dpr);
                this.render();
            }

            initEvents() {
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const width = this.canvas.offsetWidth;
                    const zoomFactor = e.deltaY > 0 ? 0.97 : 1.03;

                    if (mouseX > width - 60) {
                        if (this.options.scaleType === 'logarithmic') {
                            const logRange = this.view.maxLogPrice - this.view.minLogPrice;
                            const newLogRange = Math.max(logRange / zoomFactor, 0.01);
                            const logMid = (this.view.maxLogPrice + this.view.minLogPrice) / 2;
                            this.view.minLogPrice = logMid - newLogRange / 2;
                            this.view.maxLogPrice = logMid + newLogRange / 2;
                            this.view.minPrice = Math.pow(10, this.view.minLogPrice);
                            this.view.maxPrice = Math.pow(10, this.view.maxLogPrice);
                        } else {
                            const priceRange = this.view.maxPrice - this.view.minPrice;
                            const newPriceRange = Math.max(priceRange / zoomFactor, 0.01);
                            const priceMid = (this.view.maxPrice + this.view.minPrice) / 2;
                            this.view.minPrice = Math.max(priceMid - newPriceRange / 2, 0.01);
                            this.view.maxPrice = priceMid + newPriceRange / 2;
                            this.view.minLogPrice = Math.log10(this.view.minPrice);
                            this.view.maxLogPrice = Math.log10(this.view.maxPrice);
                        }
                    } else {
                        this.view.scaleX *= zoomFactor;
                        this.view.scaleX = Math.max(this.minScaleX, Math.min(this.maxScaleX, this.view.scaleX));
                    }
                    this.render();
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        this.isDragging = true;
                        this.lastMouseX = e.clientX;
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    if (this.isDragging) {
                        const dx = e.clientX - this.lastMouseX;
                        this.view.offsetX += dx / this.view.scaleX;
                        this.lastMouseX = e.clientX;
                        this.render();
                    } else if (this.showCrosshair) {
                        this.crosshair = { x: mouseX, y: mouseY };
                        this.render();
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) {
                        this.isDragging = false;
                    }
                });

                const scaleSelect = document.getElementById('scale-select');
                scaleSelect.addEventListener('change', (e) => {
                    this.options.scaleType = e.target.value;
                    this.render();
                });

                const crosshairButton = document.getElementById('tool-crosshair');
                crosshairButton.classList.add('active');
                crosshairButton.addEventListener('click', () => {
                    this.showCrosshair = !this.showCrosshair;
                    this.crosshair = null;
                    crosshairButton.classList.toggle('active');
                    this.render();
                });

                const maButton = document.getElementById('tool-ma');
                maButton.classList.add('active');
                maButton.addEventListener('click', () => {
                    this.showMovingAverage = !this.showMovingAverage;
                    maButton.classList.toggle('active');
                    this.render();
                });

                const resetButton = document.getElementById('tool-reset');
                resetButton.addEventListener('click', () => {
                    this.view.offsetX = 0;
                    this.view.scaleX = 1;
                    this.view.minPrice = 0;
                    this.view.maxPrice = 100;
                    this.calculatePriceRange();
                    this.render();
                });

                window.addEventListener('resize', () => this.resize());
            }

            calculatePriceRange() {
                if (!this.dataManager.data.length) return;
                const prices = this.dataManager.data.flatMap(d => [d.high, d.low]);
                const dataMinPrice = Math.min(...prices);
                const dataMaxPrice = Math.max(...prices);
                const padding = (dataMaxPrice - dataMinPrice) * 0.1;
                if (this.view.minPrice === 0 && this.view.maxPrice === 100) {
                    this.view.minPrice = Math.max(dataMinPrice - padding, 0.01);
                    this.view.maxPrice = dataMaxPrice + padding;
                    this.view.minLogPrice = Math.log10(this.view.minPrice);
                    this.view.maxLogPrice = Math.log10(this.view.maxPrice);
                }
            }

            priceToY(price, height) {
                price = Math.max(price, 0.01);
                if (this.options.scaleType === 'logarithmic') {
                    const logPrice = Math.log10(price);
                    const logRange = Math.max(this.view.maxLogPrice - this.view.minLogPrice, 0.01);
                    return height - ((logPrice - this.view.minLogPrice) / logRange) * height;
                } else {
                    const priceRange = Math.max(this.view.maxPrice - this.view.minPrice, 0.01);
                    return height - ((price - this.view.minPrice) / priceRange) * height;
                }
            }

            yToPrice(y, height) {
                if (this.options.scaleType === 'logarithmic') {
                    const logRange = Math.max(this.view.maxLogPrice - this.view.minLogPrice, 0.01);
                    const logPrice = this.view.minLogPrice + (1 - y / height) * logRange;
                    return Math.pow(10, logPrice);
                } else {
                    const priceRange = Math.max(this.view.maxPrice - this.view.minPrice, 0.01);
                    return this.view.minPrice + (1 - y / height) * priceRange;
                }
            }

            formatDate(dateStr) {
                if (!dateStr || typeof dateStr !== 'string') return '';
                const date = new Date(dateStr);
                return isNaN(date.getTime()) ? '' : date.toISOString().split('T')[0];
            }

            calculateMovingAverage(period) {
                const maData = [];
                for (let i = 0; i < this.dataManager.data.length; i++) {
                    if (i < period - 1) {
                        maData.push(null);
                        continue;
                    }
                    const sum = this.dataManager.data.slice(i - period + 1, i + 1).reduce((acc, d) => acc + d.close, 0);
                    maData.push(sum / period);
                }
                return maData;
            }

            renderIndicators() {
                if (!this.showMovingAverage) return;
                const maData = this.calculateMovingAverage(5);
                const width = this.canvas.offsetWidth;
                const chartHeight = this.canvas.offsetHeight - 30;
                const candleWidth = this.options.candleWidth * this.view.scaleX;
                const spacing = 2;

                this.ctx.strokeStyle = '#0000ff';
                this.ctx.beginPath();
                maData.forEach((ma, i) => {
                    if (ma === null) return;
                    const x = (i * (candleWidth + spacing) + this.view.offsetX) * this.view.scaleX;
                    if (x < -candleWidth || x > width) return;
                    const y = this.priceToY(ma, chartHeight);
                    if (i === 0 || maData[i - 1] === null) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                });
                this.ctx.stroke();
            }

            renderCrosshair() {
                if (!this.showCrosshair || !this.crosshair) return;
                const { x, y } = this.crosshair;
                const width = this.canvas.offsetWidth;
                const chartHeight = this.canvas.offsetHeight - 30;

                this.ctx.strokeStyle = '#666';
                this.ctx.setLineDash([5, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, chartHeight);
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(width - 60, y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                const price = this.yToPrice(y, chartHeight);
                const candleIndex = Math.round((x - this.view.offsetX) / ((this.options.candleWidth * this.view.scaleX + 2) * this.view.scaleX));
                if (candleIndex < 0 || candleIndex >= this.dataManager.data.length) return;
                const time = this.dataManager.data[candleIndex]?.time || '';

                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(x + 10, y - 30, 120, 40);
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px Arial';
                this.ctx.fillText(`Price: ${price.toFixed(2)}`, x + 15, y - 15);
                this.ctx.fillText(`Time: ${this.formatDate(time)}`, x + 15, y);
            }

            renderGrid() {
                const width = this.canvas.offsetWidth;
                const height = this.canvas.offsetHeight;
                const axisMargin = 30;
                const chartHeight = height - axisMargin;
                const candleWidth = this.options.candleWidth * this.view.scaleX;
                const spacing = 2;

                this.ctx.strokeStyle = this.options.gridColor;
                this.ctx.lineWidth = 1;

                const priceSteps = 5;
                for (let i = 0; i <= priceSteps; i++) {
                    const y = (chartHeight * i) / priceSteps;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, chartHeight - y);
                    this.ctx.lineTo(width - 60, chartHeight - y);
                    this.ctx.stroke();
                }

                const labelInterval = Math.max(1, Math.floor(100 / (candleWidth + spacing)));
                this.dataManager.data.forEach((candle, i) => {
                    if (i % labelInterval === 0) {
                        const x = (i * (candleWidth + spacing) + this.view.offsetX) * this.view.scaleX;
                        if (x >= 0 && x <= width - 60) {
                            this.ctx.beginPath();
                            this.ctx.moveTo(x, 0);
                            this.ctx.lineTo(x, chartHeight);
                            this.ctx.stroke();
                        }
                    }
                });
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = this.options.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (!this.dataManager.data.length) return;

                this.calculatePriceRange();
                const width = this.canvas.offsetWidth;
                const height = this.canvas.offsetHeight;
                const axisMargin = 30;
                const chartHeight = height - axisMargin;
                const candleWidth = this.options.candleWidth * this.view.scaleX;
                const spacing = 2;

                this.renderGrid();

                const startIndex = Math.max(0, Math.floor(-this.view.offsetX / (candleWidth + spacing)));
                const endIndex = Math.min(this.dataManager.data.length, Math.ceil((width - this.view.offsetX) / (candleWidth + spacing)));

                this.dataManager.data.slice(startIndex, endIndex).forEach((candle, i) => {
                    const trueIndex = startIndex + i;
                    const x = (trueIndex * (candleWidth + spacing) + this.view.offsetX) * this.view.scaleX;
                    if (x < -candleWidth || x > width) return;

                    const isUp = candle.close >= candle.open;
                    this.ctx.fillStyle = isUp ? this.options.upColor : this.options.downColor;

                    const highY = this.priceToY(candle.high, chartHeight);
                    const lowY = this.priceToY(candle.low, chartHeight);
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + candleWidth / 2, highY);
                    this.ctx.lineTo(x + candleWidth / 2, lowY);
                    this.ctx.strokeStyle = this.ctx.fillStyle;
                    this.ctx.stroke();

                    const openY = this.priceToY(candle.open, chartHeight);
                    const closeY = this.priceToY(candle.close, chartHeight);
                    const bodyHeight = Math.abs(openY - closeY);
                    const bodyY = Math.min(openY, closeY);
                    this.ctx.fillRect(x, bodyY, candleWidth, bodyHeight);
                });

                this.renderIndicators();
                this.renderCrosshair();

                this.ctx.strokeStyle = this.options.axisColor;
                this.ctx.beginPath();
                this.ctx.moveTo(width - 60, 0);
                this.ctx.lineTo(width - 60, chartHeight);
                this.ctx.stroke();

                this.ctx.fillStyle = this.options.axisColor;
                this.ctx.font = '12px Arial';
                const priceSteps = 5;
                for (let i = 0; i <= priceSteps; i++) {
                    const y = (chartHeight * i) / priceSteps;
                    const price = this.yToPrice(y, chartHeight);
                    this.ctx.fillText(price.toFixed(2), width - 55, chartHeight - y);
                }

                this.ctx.beginPath();
                this.ctx.moveTo(0, chartHeight);
                this.ctx.lineTo(width - 60, chartHeight);
                this.ctx.stroke();

                const labelInterval = Math.max(1, Math.floor(100 / (candleWidth + spacing)));
                this.dataManager.data.forEach((candle, i) => {
                    if (i % labelInterval === 0) {
                        const x = (i * (candleWidth + spacing) + this.view.offsetX) * this.view.scaleX;
                        if (x >= 0 && x <= width - 60) {
                            this.ctx.fillText(this.formatDate(candle.time), x, chartHeight + 20);
                        }
                    }
                });
            }
        }

        const btcUsdData = [
            { time: "2025-01-01", open: 93811.12, high: 95000.00, low: 93017.83, close: 94000.00 },
            { time: "2025-01-07", open: 94000.00, high: 96000.00, low: 93500.00, close: 95500.00 },
            { time: "2025-01-14", open: 95500.00, high: 97000.00, low: 95000.00, close: 96500.00 },
            { time: "2025-01-21", open: 96500.00, high: 105104.85, low: 96000.00, close: 103000.00 },
            { time: "2025-01-28", open: 103000.00, high: 104500.00, low: 102000.00, close: 104030.97 },
            { time: "2025-02-04", open: 104030.97, high: 101987.25, low: 100000.00, close: 100500.00 },
            { time: "2025-02-11", open: 100500.00, high: 101000.00, low: 95000.00, close: 96000.00 },
            { time: "2025-02-18", open: 96000.00, high: 97000.00, low: 90000.00, close: 91000.00 },
            { time: "2025-02-25", open: 91000.00, high: 92000.00, low: 81975.61, close: 81975.61 },
            { time: "2025-03-04", open: 81975.61, high: 85000.00, low: 80974.66, close: 83000.00 },
            { time: "2025-03-11", open: 83000.00, high: 87000.00, low: 82000.00, close: 85000.00 },
            { time: "2025-03-18", open: 85000.00, high: 90000.00, low: 84000.00, close: 87000.00 },
            { time: "2025-03-25", open: 87000.00, high: 90867.72, low: 86000.00, close: 82381.03 },
            { time: "2025-04-01", open: 82381.03, high: 85000.00, low: 77771.33, close: 83000.00 },
            { time: "2025-04-08", open: 83000.00, high: 87000.00, low: 82000.00, close: 86000.00 },
            { time: "2025-04-15", open: 86000.00, high: 90000.00, low: 85000.00, close: 89000.00 },
            { time: "2025-04-22", open: 89000.00, high: 93000.00, low: 88000.00, close: 92000.00 },
            { time: "2025-04-29", open: 92000.00, high: 95029.76, low: 91000.00, close: 94226.83 },
            { time: "2025-05-06", open: 94226.83, high: 96000.00, low: 94389.40, close: 95000.00 },
            { time: "2025-05-13", open: 95000.00, high: 100000.00, low: 95000.00, close: 99000.00 },
            { time: "2025-05-20", open: 99000.00, high: 105000.00, low: 98000.00, close: 104000.00 },
            { time: "2025-05-22", open: 104000.00, high: 111891.30, low: 103500.00, close: 111529.83 },
            { time: "2025-05-27", open: 111529.83, high: 111529.83, low: 108000.00, close: 109000.00 },
            { time: "2025-06-03", open: 109000.00, high: 110000.00, low: 105000.00, close: 106000.00 },
            { time: "2025-06-06", open: 106000.00, high: 107000.00, low: 104000.00, close: 104341.62 }
        ];

        const canvas = document.getElementById('chart');
        const chart = new Chart(canvas, {
            data: btcUsdData,
            candleWidth: 10,
            upColor: '#F08852',
            downColor: '#6D96E7',
            background: '#FFFFFF',
            axisColor: '#333333',
            scaleType: 'linear',
        });

        // Example: Load CSV data dynamically
        // chart.dataManager.loadDataFromCSV('data/btc-usd.csv');
    </script>
</body>

</html>